# Поддержка грядущего стандарта Ада 202х в GNAT Community Edition 2021

Запустить: [![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/reznikmm/ada-howto/ce-2021?filepath=%2Fhome%2Fjovyan%2Fce2021.ipynb "Run me!")

В мае 2021г. вышла новая редакция компилятора Ada -
[GNAT Community Edition 2021](https://www.adacore.com/download
  "Download").
В ней, среди прочих изменений и улучшений, реализована значительная часть новых
возможностей
[грядущего стандарта Ады](http://www.ada-auth.org/standards/ada2x.html
"Ada 202x Language Reference Manual")
который AdaCore теперь называет Ada 2022.

Давайте познакомимся с ними поближе. Благодаря
[Jupyter Ada Kernel](https://github.com/reznikmm/jupyter)
поэкспериментировать с примерами использования этих возможностей можно прямо
в браузере. Для этого откройте данный "блокнот" просто перейдя по ссылке на 
[mybinder](https://mybinder.org/v2/gh/reznikmm/ada-howto/ce-2021?filepath=%2Fhome%2Fjovyan%2Fce2021.ipynb
  "Run me!").
(Предупреждение: загрузка блокнота может занять некоторое время необходимое для
сборки и запуска контейнера).

Если Вы ранее не работали с блокнотами Jupyter - не пугайтесь, это не сложно.
Основная идея в том, что Вы может выполнять ячейки с кодом. Для этого на ячейке
нажмите `Ctrl+Enter` либо воспользуйтесь меню или иконками. В Jupyter Ada Kernel
ячейка может содержать
[спецификатор контекста](http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-10-1-2.html#S0253
  "context clauses"),
[оператор](http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-5-1.html#S0146
  "statements") или
[определение](http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-3-11.html#S0087
  "declarative items"),
либо несколько таких элементов, но одного типа. Если ячуйка собержит тело 
подпрограммы или пакета, то спецификация должна быть в той же ячейке.
Некоторые ячейки зависят от преыдущих, пожтому лучше выполнять ячейки по порядку.

## Содержание
 * [Активация Ada 202x](#%D0%90%D0%BA%D1%82%D0%B8%D0%B2%D0%B0%D1%86%D0%B8%D1%8F-Ada-202x)
 * [Больше выразительности и удобства](#%D0%91%D0%BE%D0%BB%D1%8C%D1%88%D0%B5-%D0%B2%D1%8B%D1%80%D0%B0%D0%B7%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B8-%D1%83%D0%B4%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B0)
   * [Атрибут 'Image для всех типов](#%D0%90%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82-'Image-%D0%B4%D0%BB%D1%8F-%D0%B2%D1%81%D0%B5%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2)
   * [Переопределение атрибута 'Image](#%D0%9F%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B0%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D0%B0-'Image)
   * [Числовые и строковые литералы для пользовательских типов](#%D0%A7%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2)
   * [Итеративные ассоциации в агрегатах массивов](#%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D0%B0%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%86%D0%B8%D0%B8-%D0%B2-%D0%B0%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%82%D0%B0%D1%85-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%BE%D0%B2)
   * [Дельта агрегаты](#%D0%94%D0%B5%D0%BB%D1%8C%D1%82%D0%B0-%D0%B0%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%82%D1%8B)
   * [Агрегаты контейнеров](#%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%82%D1%8B-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%BE%D0%B2)
   * [Плюха @](#%D0%9F%D0%BB%D1%8E%D1%85%D0%B0-@)
   * [Поддержка Map-Reduce](#%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0-Map-Reduce)
   * [Фильтры для итераторов](#%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D1%8B-%D0%B4%D0%BB%D1%8F-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2)
   * [Упрощенное переименование](#%D0%A3%D0%BF%D1%80%D0%BE%D1%89%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
   * [Выражения‐определения](#%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%E2%80%90%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)
   * [Статические функции](#%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
   * [Доступ к значениям спецификации представления](#%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)
 * [Библиотека времени исполнения](#%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F)
   * [Арифметика с произвольной точностью](#%D0%90%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0-%D1%81-%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C%D1%8E)
   * [Атомарные операции](#%D0%90%D1%82%D0%BE%D0%BC%D0%B0%D1%80%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8)
 * [Исправления](#%D0%98%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BF%D1%80%D0%BE%D1%87%D0%B5%D0%B5)
   * [Импорт С-функций с переменным числом аргументов](#%D0%98%D0%BC%D0%BF%D0%BE%D1%80%D1%82-%D0%A1-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-%D1%81-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%BC-%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%BC-%D0%B0%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
 * [Что после Ады 2022?](#%D0%A7%D1%82%D0%BE-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5-%D0%90%D0%B4%D1%8B-2022?)
   * [Дополнительный when](#%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-when)
   * [Сопоставление с шаблоном](#%D0%A1%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%BC)
   * [Фиксированная нижняя граница массива](#%D0%A4%D0%B8%D0%BA%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F-%D0%BD%D0%B8%D0%B6%D0%BD%D1%8F%D1%8F-%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)
   * [Вызов подпрограмм через точку для нетеговых типов](#%D0%92%D1%8B%D0%B7%D0%BE%D0%B2-%D0%BF%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%82%D0%BE%D1%87%D0%BA%D1%83-%D0%B4%D0%BB%D1%8F-%D0%BD%D0%B5%D1%82%D0%B5%D0%B3%D0%BE%D0%B2%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2)
* [Заключение](#%D0%97%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)

## Активация Ada 202x

Первое, что нужно сделать, это указать компилятору, что Вы используете новый стандарт.
Обычно это делается при помощи ключа компилятора `-gnat2022`.
Указать его можно в коммандной строке, а лучше в проектном файле.
Но в этом блокноте мы будем пользоваться директивой компилятора 

```ada
pragma Ada_2022;
```

Если вы хотите использовать синтаксис с квадратными скобками
(что допускается в Аде 202х), то нужно также указать ключ
`-gnatX` либо использовать

```ada
pragma Extensions_Allowed (On);
```

Следующая ячейка должна выполнятся первой, иначе последующие ячейки работать не будут!
(Также нам пригодится пакет `Ada.Text_IO;`).




```Ada
pragma Ada_2022;
pragma Extensions_Allowed (On);
with Ada.Text_IO;
```

## Больше выразительности и удобства

Авторы стандарта стараются сделать язык более выразительным и удобным. К нововведениям этой группы можно отнести литералы пользовательских типов, агрегаты контейнеров, новые виды агрегатов массивов и записей и прочее. Давайте начнем с атрибута `'Image`.

### Атрибут `'Image` для всех типов

В новом стандарте атрибут `'Image` работает для всех типов, а не только для скалярных, как было раньше. (Если Вы пропустили 
"[технические правки 2016](http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-3-5.html#I1681)"
стандарте Ada 2012, то знайте, теперь префиксом атрибута может выступать не только тип,
но и значение. Запись `My_Type'Image (Value)` можно сократить до `Value'Image`).


```Ada
Integer_Array : array (1 .. 3) of Integer := (1, 2, 3);
```


```Ada
Ada.Text_IO.Put_Line (Integer_Array'Image);
```




    
    [ 1,  2,  3]




### Переопределение атрибута `'Image`

Также можно задать подпрограмму для отображения значений своего типа.
В этой версии авторы компилятора реализовали переопределение так, как написано в стандарте.

Основная идея в том, чтобы определить аспект `Put_Image` для вашего типа используя подпрограммы из предопределённого пакета:


```Ada
with Ada.Strings.Text_Buffers;
```


```Ada
package Source_Locations is
   type Source_Location is record
      Line   : Positive;
      Column : Positive;
   end record
     with Put_Image => My_Put_Image;

   procedure My_Put_Image
     (Buffer : in out Ada.Strings.Text_Buffers.Root_Buffer_Type'Class;
      Value  : Source_Location);
end Source_Locations;

package body Source_Locations is

   procedure My_Put_Image
     (Buffer : in out Ada.Strings.Text_Buffers.Root_Buffer_Type'Class;
      Value  : Source_Location)
   is
      Line   : constant String := Value.Line'Image;
      Column : constant String := Value.Column'Image;
      Result : constant String :=
        Line (2 .. Line'Last) & ':' & Column (2 .. Column'Last);
   begin
      Buffer.Put (Result);
   end My_Put_Image;

end Source_Locations;
```

Создадим теперь объект нашего типа:


```Ada
Line_10 : Source_Locations.Source_Location := (Line => 10, Column => 1);
```

И напечатаем его:


```Ada
Ada.Text_IO.Put_Line ("Text position: " & Line_10'Image);
```




    Text position: 10:1




### Числовые и строковые литералы для пользовательских типов 
    
Появилась возможность использовать литералы языка для своих типов.
Это позволяет избежать явного вызова функции преобразования.

Это удобно, когда вводишь свои строчные и числовые типы. Давайте, для примера, создадим
свой строчный тип на основе `Unbounded_String`. Нам понадобятся следующие пакеты:


```Ada
with Ada.Strings.Unbounded;
with Ada.Strings.UTF_Encoding.Wide_Wide_Strings;
```

Теперь определим сам тип и аспект `String_Literal` для него:


```Ada
type My_String is new Ada.Strings.Unbounded.Unbounded_String
  with String_Literal => From_String;

function From_String (Text : Wide_Wide_String) return My_String is
 (To_Unbounded_String
   (Ada.Strings.UTF_Encoding.Wide_Wide_Strings.Encode
     (Text)));

Five : My_String := "5";

```


```Ada
Ada.Text_IO.Put_Line (To_String (Five));
```




    5




### Итеративные ассоциации в агрегатах массивов

Иногда требуется конструировать такие значения массивов, что элементы заданы, как функция от индекса. Здесь пригодятся агрегаты в новой форме. Ассоциации этих агрегатов нацинаются со слова `for`:


```Ada
type Integer_Matrix is array (1 .. 3, 1 .. 3) of Integer;

X_3x3 : Integer_Matrix :=
 (for K in 1 .. 3 =>
   (for J in 1 .. 3 => (K * 10 + J)));
```


```Ada
Ada.Text_IO.Put_Line (X_3x3'Image);
```




    
    [
     [ 11,  12,  13],
    
     [ 21,  22,  23],
    
     [ 31,  32,  33]]




### Дельта агрегаты

Для агрегатов записей тоже есть улучшения. Если вам нужно изменить лишь некоторые компоненты записи, может пригодится *дельта агрегат*. В нем нужно указать базовое значение и те компоненты для которых вы хотите изменить значение. Это удобно, когда общее количество компонент записи сравнительно велико, ведь вам не нужно перечеслять из все:


```Ada
type Vector_3D is record
   X, Y, Z : Natural;
end record;

Base_Value : constant Vector_3D := (1, 2, 3);

Projection : constant Vector_3D := (Base_Value with delta Z => 0);
```

Проэкция вычисляется по базовому значению. Координата Z устанавливается равной нулю. Напечатаем его:


```Ada
Ada.Text_IO.Put_Line (Projection'Image);
```




    
    (X =>  1,
     Y =>  2,
     Z =>  0)




### Агрегаты контейнеров

Теперь эта возможность реализована в компиляторе.
Допустим у нас есть тип-контейнер, "конструктор" пустого когтейнера и операция добавления элемента.
С помощью нового апекта `Aggregate` мы можем включить агрегаты, как у массивов.


```Ada
package Stacks is
   type Stack is private
     with Aggregate => (Empty => Empty_Stack, Add_Unnamed => Push);

   function Empty_Stack return Stack;

   procedure Push (Self : in out Stack; Value : Integer);
private
   type Integer_Array is array (Positive range <>) of Integer;
   type Stack is record
      Last : Natural := 0;
      Data : Integer_Array (1 .. 10);
   end record;
end Stacks;
                                
package body Stacks is

   function Empty_Stack return Stack is (Last => 0, Data => (others => <>));

   procedure Push (Self : in out Stack; Value : Integer) is
   begin
      Self.Last := Self.Last + 1;
      Self.Data (Self.Last) := Value;
   end Push;

end Stacks;
```

Следующая запись создаст стек и положит туда три элемента:


```Ada
S : Stacks.Stack := [1, 2, 3];
```

Есть вариант и для контейнеров с ключами.


```Ada
with Ada.Containers.Ordered_Maps;
```


```Ada
package Float_Maps is new Ada.Containers.Ordered_Maps
  (Integer, Float);

Y : Float_Maps.Map := [-10 => 1.0, 0 => 2.5, 10 => 5.51];
```

Вот какой получится результат:


```Ada
Ada.Text_IO.Put_Line (Y'Image);
```




    
    [-10 =>  1.00000E+00,  0 =>  2.50000E+00,  10 =>  5.51000E+00]




### Поддержка Map-Reduce

Техника программирования Map-Reduce [широко известна](https://ru.wikipedia.org/wiki/MapReduce).
В место того, чтобы писать подпрограммы и циклы, предлагается другой механизм при котором входные и промежуточные значения существуют в виде потока значений. Часто это позволяет ускорить обработку. В новом стандарте вводится новый атрибут `'Reduce`:

```ada
V'Reduce(Reducer, Initial_Value[, Combiner]) 
```

Где в качестве V может выступать одно из

* массив
* контейнер
* специальная конструкция _value_sequence_, синтаксис которой сходен с агрегатом контейнеров

```
value_sequence ::=
  '[' [parallel[(chunk_specification)]] iterated_component_association ']'
```

В итоге программа переберет все элементы V и начальное значение Initial_Value выполнит над ними подпрограмму Reducer, которая может быть функцией или процедурой:

```ada
function Reducer
  (Accumulator : Accum_Type;
   Value      : Value_Type) return Accum_Type;

procedure Reducer
  (Accumulator : in out Accum_Type;
   Value       : in Value_Type);
```

Вот пример вычисления суммы элементов массива


```Ada
Arr : array (1 .. 3) of Integer := (1, 2, 3);
X : Integer := Arr'Reduce ("+", 0);
```


```Ada
Ada.Text_IO.Put_Line (X'Image);
```




     6




### Плюха @

Вводится сокращение в операторах присваивания для обозначение левой части. Это сделано чтобы избежать дублирование кода и связанных с этим ошибок, когда левая часть очень длинная. В любом месте выражения справа от `:=` можно написать `@`. Вот илюстрация (довольно бессмысленная):


```Ada
declare 
    Text : String (1 .. 10) := (others => ' ');
    J    : Positive := 2;
    K    : Positive := 1;
begin
    Text (10 - 2 * J + K / 3 + (K + J) / 2) := Character'Succ (@);
    --  Here '@' replaces "Text (10 - 2 * J + K / 3 + (K + J) / 2)"
    Ada.Text_IO.Put_Line (">" & Text & "<");
end;
```




    >      !   <




### Фильтры для итераторов
Во всех конструкциях, где используются итераторы, теперь можно добавлять фильтр — условия при срабатывании которого элементы участвуют в итерации, а остальные пропускаются.


```Ada
for J in 1 .. 10 when J mod 2 = 0 loop
   Ada.Text_IO.Put_Line (J'Img);
end loop;
```




     2
     4
     6
     8
     10




### Упрощенное переименование
При переименовании объекта можно опустить тип, если он известен из контекста.


```Ada
declare
   Text : String := "Text";
   T renames Text;
begin
   Ada.Text_IO.Put_Line (T);
end;
```




    Text




### Выражения‐определения
Для удобства записи контрактов вводится новый вид выражений


```Ada
declare
   Result : constant Integer :=
    (declare
       X : constant Integer := 2;
       Y : constant Integer := 4;
     begin X**2 + X * Y + Y**2);
begin
   Ada.Text_IO.Put_Line (Result'Image);
end;
```




     28




### Статические функции
Теперь функцию-выражение можно пометить, как Static и использовать в котексте, где компилятор ожидает статическое выражение.


```Ada
function Half_Size (S : Integer) return Integer is (S / 2) with Static;

type Int is range 1 .. Half_Size (10);
```

### Доступ к значениям спецификации представления

В Аде литералам перечислимых типов можно назначать произвольное представление:


```Ada
type My_Boolean is new Boolean;
for My_Boolean use (False => 3, True => 6);
```

В новом стандарте можно легко получить эти значения с помощью нового атрибута `'Enum_Rep`.
Атрибут `'Enum_Val` работает в обратном направлении.


```Ada
Ada.Text_IO.Put ("Enum_Rep(False) =");
Ada.Text_IO.Put_Line (Integer'Image (My_Boolean'Enum_Rep (False)));
Ada.Text_IO.Put ("Enum_Val (3) = ");
Ada.Text_IO.Put_Line (My_Boolean'Enum_Val (3)'Image);
```




    Enum_Rep(False) = 3
    Enum_Val (3) = FALSE




## Библиотека времени исполнения
### Арифметика с произвольной точностью

Два новых пакет Big_Integer и Big_Reals позволяют производить вычисления с произвольной точностью.


```Ada
with Ada.Numerics.Big_Numbers.Big_Integers;
use Ada.Numerics.Big_Numbers.Big_Integers;
```

Например, посчитаем 2²²²


```Ada
Ada.Text_IO.Put_Line (Big_Integer'Image(2 ** 222));
```




     6739986666787659948666753771754907668409286105635143120275902562304




### Атомарные операции

Для программирования различных нискоуровневых параллельных операций могут пригодиться
такие атомарные операции, как "сравнить и установить" (Test_And_Set) или "сравнить и заменить" (Compare_And_Exchange). Появился стандартный способ их использовать


```Ada
with System.Atomic_Operations.Integer_Arithmetic;
with System.Atomic_Operations.Modular_Arithmetic;
with System.Atomic_Operations.Exchange;
with System.Atomic_Operations.Test_And_Set;
```

Первые три пакета - настраиваемые, а последний предоставляет свой атомарный тип. С помощью Integer_Arithmetic и Modular_Arithmetic можно легко организовать атомарный счётчик ссылок.

## Исправления и прочее

### Импорт С-функций с переменным числом аргументов

Добавили совые соглашения о передаче параметров `Convention => C_Variadic_*`. Просто `C` использовать нельзя из-за 
[несовместимости ABI](https://stackoverflow.com/questions/35819037/variadic-function-in-ada-c-ada-binding/55305307#55305307):


```Ada
with Interfaces.C;
```


```Ada
procedure Printf (Format : in Interfaces.C.char_array; V : Interfaces.C.int)
  with Import => True, Convention => C_Variadic_2, External_Name => "printf";
```


```Ada
Printf (Interfaces.C.To_C("X=%d"), 12);
```




    X=12



## Что после Ады 2022?

В GNAT Community 2021 добавили несколько эксперементальных возможностей, которые не вошли в грядущий стандарт Ада 2022. Таким образом появляется возможность заранее попробовать их на практике.

Эти возможности доступны только, если используется ключ `-gnatX`.


```Ada
%cargs -gnatX
```




    Now -cargs options are: -gnatX



### Дополнительный when

Такие операторы, как `return`, `raise`, `goto` расширены дополнительным условием:


```Ada
procedure Check_Extra_When1 (X : Integer) is
begin
   goto End_Of_Call when X = 0;

   return when X > 0;

   raise Program_Error when X < 0;

   <<End_Of_Call>>
end;
```

### Сопоставление с шаблоном

В начальной реализация сопостовния с шаблоном реализовали для составных (не приватных) типов.
Шаблон значения записывается как агрегат, но в отличии от агрегата, вместо значений дискретных подтипов могут стоять наименования подтипов.
Коробочка (`<>`) обозначает произвольное значение дискретного типа.

```ada
type Rec is record
   F1, F2 : Integer;
end record;
    
X : Rec := (1, 2);
case X is
   when (F1 => Positive, F2 => Positive) =>
      Ada.Text_IO.Put_Line ("case 1");
   when (F1 => Natural, F2 => <>) | (F1 => <>, F2 => Natural) =>
      Ada.Text_IO.Put_Line ("case 2");
   when others =>
      Ada.Text_IO.Put_Line ("case 3");
end case;
```

Также реализована "разборка" составного значения на компоненты. Вот пример синтаксиса
```ada
case X is
   when (F1 => Positive is Abc, F2 => Positive) =>
      Ada.Text_IO.Put_Line ("case 1" & Abc'Image);
   when (F1 => Natural is N1, F2 => <N2>) |
           (F1 => <N2>, F2 => Natural is N1) =>
      Ada.Text_IO.Put_Line ("case 2" & N1'Image & N2'Image);
   when others =>
      Ada.Text_IO.Put_Line ("case 3");
end case;
```

### Фиксированная нижняя граница массива

В Аде индексируемые типы (массивы) могут быть объявлены либо с указанием границ, либо без.
Это расширение позволяет задать нижнюю границу, а верхнюю оставить не указанной.
В ряди случаев это позволяет получить более простой код, ведь нижняя граница заранее известна.
Также это позволяет компилятору выполнить некоторые дополнительные оптимизации.


```Ada
type Vector is array (Positive range 1 .. <>) of Integer;
type Matrix is array (Natural range 0 .. <>, Natural range 0 .. <>) of Integer;
```

### Вызов подпрограмм через точку для нетеговых типов

Теперь можно пользоваться синтаксисом Object.Method не только для теговых типов, но и для остальных.

Ada.Text_IO.Current_Output.Put_Line ("Hello!");

## Заключение

Скорее всего данная версия компилятора будет последней в цепочке релизов GNAT Community.
В дальнейшем компилятор собранный из открытых исходных текстов GCC можно будет установить с помощью пакетного менеджера [alire](alire.ada.dev/).

* [Телеграм чат](https://t.me/ada_ru_chat)
* [Сайт ada_ru](https://www.ada-ru.org)
* [Форум ada_ru](https://www.ada-ru.org/forum)
